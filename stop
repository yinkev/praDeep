#!/usr/bin/env python3
from __future__ import annotations

import argparse
import os
from pathlib import Path
import subprocess
from typing import Iterable


def _which(cmd: str) -> str | None:
    for path in os.environ.get("PATH", "").split(os.pathsep):
        candidate = Path(path) / cmd
        if os.name == "nt":
            exe = candidate.with_suffix(".exe")
            if exe.exists() and os.access(exe, os.X_OK):
                return str(exe)
        if candidate.exists() and os.access(candidate, os.X_OK):
            return str(candidate)
    return None


def _collect_pids_unix(port: int) -> list[int]:
    lsof = _which("lsof")
    if not lsof:
        return []
    result = subprocess.run([lsof, "-ti", f":{port}"], capture_output=True, text=True)
    if result.returncode != 0:
        return []
    pids: list[int] = []
    for line in result.stdout.splitlines():
        line = line.strip()
        if not line:
            continue
        try:
            pids.append(int(line))
        except ValueError:
            continue
    return pids


def _collect_pids_windows(port: int) -> list[int]:
    netstat = _which("netstat")
    if not netstat:
        return []
    result = subprocess.run([netstat, "-ano"], capture_output=True, text=True)
    if result.returncode != 0:
        return []
    pids: list[int] = []
    for line in result.stdout.splitlines():
        if f":{port} " not in line:
            continue
        parts = line.split()
        if len(parts) < 5:
            continue
        pid = parts[-1]
        try:
            pids.append(int(pid))
        except ValueError:
            continue
    return pids


def _kill_pids(pids: Iterable[int], *, dry_run: bool) -> None:
    if not pids:
        return
    for pid in sorted(set(pids)):
        if dry_run:
            print(f"Would kill PID {pid}")
            continue
        if os.name == "nt":
            subprocess.run(["taskkill", "/PID", str(pid), "/F"], check=False)
        else:
            try:
                os.kill(pid, 9)
            except ProcessLookupError:
                pass


def stop_ports(ports: Iterable[int], *, dry_run: bool) -> None:
    for port in ports:
        if dry_run:
            print(f"Port {port}")
        if os.name == "nt":
            pids = _collect_pids_windows(port)
        else:
            pids = _collect_pids_unix(port)
        _kill_pids(pids, dry_run=dry_run)


def main() -> int:
    parser = argparse.ArgumentParser(description="Stop praDeep backend + frontend")
    parser.add_argument("--dry-run", action="store_true", help="Show which ports would be stopped")
    args = parser.parse_args()

    ports = [8783, 3783]
    if args.dry_run:
        print("Stopping praDeep ports:")
    stop_ports(ports, dry_run=args.dry_run)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
